'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var get = _interopDefault(require('lodash.get'));
var Contentful = require('@contentful/rich-text-types');
var flatmap = _interopDefault(require('lodash.flatmap'));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

/**
 * Ensures that data defaults to an empty object.
 */
var getDataOfDefault = function (value) { return value || {}; };

var defaultSchema = {};
/**
 * Creates an instance of Schema from json.
 *
 * @export
 * @param {SchemaJSON} [schema=defaultSchema]
 * @returns {Schema}
 */
function fromJSON(schema) {
    if (schema === void 0) { schema = defaultSchema; }
    return {
        /**
         * Check if a `node` is void based on the schema rules.
         *
         * @param {ContentfulNonTextNodes} node
         * @returns
         */
        isVoid: function (node) {
            var root = Object.values(Contentful.BLOCKS).includes(node.nodeType) ? 'blocks' : 'inlines';
            return get(schema, [root, node.nodeType, 'isVoid'], false);
        },
    };
}

function toSlatejsDocument(_a) {
    var document = _a.document, schema = _a.schema;
    return {
        object: 'document',
        data: getDataOfDefault(document.data),
        nodes: flatmap(document.content, function (node) { return convertNode(node, fromJSON(schema)); }),
    };
}
function convertNode(node, schema) {
    var nodes = [];
    if (node.nodeType === 'text') {
        var slateText = convertTextNode(node);
        nodes.push(slateText);
    }
    else {
        var contentfulNode = node;
        var childNodes = flatmap(contentfulNode.content, function (childNode) { return convertNode(childNode, schema); });
        var object = getSlateNodeObjectValue(contentfulNode.nodeType);
        var slateNode = void 0;
        if (object === 'inline') {
            slateNode = createInlineNode(contentfulNode, childNodes, schema);
        }
        else if (object === 'block') {
            slateNode = createBlockNode(contentfulNode, childNodes, schema);
        }
        else {
            throw new Error("Unexpected slate object '" + object + "'");
        }
        nodes.push(slateNode);
    }
    return nodes;
}
function createBlockNode(contentfulBlock, childNodes, schema) {
    return {
        object: 'block',
        type: contentfulBlock.nodeType,
        nodes: childNodes,
        isVoid: schema.isVoid(contentfulBlock),
        data: getDataOfDefault(contentfulBlock.data),
    };
}
function createInlineNode(contentfulBlock, childNodes, schema) {
    return {
        object: 'inline',
        type: contentfulBlock.nodeType,
        nodes: childNodes,
        isVoid: schema.isVoid(contentfulBlock),
        data: getDataOfDefault(contentfulBlock.data),
    };
}
function convertTextNode(node) {
    var _a = node, _b = _a.marks, marks = _b === void 0 ? [] : _b, value = _a.value, data = _a.data;
    var slateText = {
        object: 'text',
        leaves: [
            {
                object: 'leaf',
                text: value,
                marks: marks.map(function (mark) { return (__assign({}, mark, { data: {}, object: 'mark' })); }),
            },
        ],
        data: getDataOfDefault(data),
    };
    return slateText;
}
function getSlateNodeObjectValue(nodeType) {
    if (Object.values(Contentful.BLOCKS).includes(nodeType)) {
        return 'block';
    }
    else if (Object.values(Contentful.INLINES).includes(nodeType)) {
        return 'inline';
    }
    else {
        throw new Error("Unexpected contentful nodeType '" + nodeType + "'");
    }
}

function toContentfulDocument(_a) {
    var document = _a.document, schema = _a.schema;
    return {
        nodeType: Contentful.BLOCKS.DOCUMENT,
        data: getDataOfDefault(document.data),
        content: flatmap(document.nodes, function (node) { return convertNode$1(node, fromJSON(schema)); }),
    };
}
function convertNode$1(node, schema) {
    var nodes = [];
    switch (node.object) {
        case 'block':
        case 'inline':
            var slateNode = node;
            var content = flatmap(slateNode.nodes, function (childNode) { return convertNode$1(childNode, schema); });
            if (!slateNode.type) {
                throw new Error("Unexpected slate node " + JSON.stringify(slateNode));
            }
            var contentfulBlock = {
                nodeType: slateNode.type,
                content: [],
                data: getDataOfDefault(slateNode.data),
            };
            if (!schema.isVoid(contentfulBlock)) {
                contentfulBlock.content = content;
            }
            nodes.push(contentfulBlock);
            break;
        case 'text':
            convertText(node).forEach(function (childNode) { return nodes.push(childNode); });
            break;
        default:
            assertUnreachable(node);
            break;
    }
    return nodes;
}
function convertText(node) {
    return node.leaves.map(function (leaf) { return ({
        nodeType: 'text',
        value: leaf.text,
        marks: leaf.marks ? leaf.marks.map(function (mark) { return ({ type: mark.type }); }) : [],
        data: getDataOfDefault(node.data),
    }); });
}
function assertUnreachable(object) {
    throw new Error("Unexpected slate object " + object);
}

exports.toSlatejsDocument = toSlatejsDocument;
exports.toContentfulDocument = toContentfulDocument;
//# sourceMappingURL=contentful-slatejs-adapter.es5.js.map
